---
title: Contract Testing
weight: 3
---

# <%= current_page.data.title %>

<div id="main-content" class="wiki-content">
                           
        <p><span style="color: rgb(73,80,87);text-decoration: none;"><span style="color: rgb(41,41,41);text-decoration: none;">&nbsp;</span>Contract testing is a methodology for ensuring that two separate systems (such as two microservices) are compatible and are able to communicate with one other. It captures the interactions that are exchanged between each service, storing them in a<span>&nbsp;</span></span><strong><em style="text-decoration: none;text-align: left;">contract</em></strong><span style="color: rgb(73,80,87);text-decoration: none;">, which can then be used to verify that both parties adhere to it</span></p><p class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi">The<span>&nbsp;</span><a style="text-decoration: underline;" href="https://docs.pact.io/" class="external-link" rel="nofollow">Pact Framework</a><span>&nbsp;</span>is an open source project for contract testing with support for several platforms like Ruby, JavaScript, Java and others through its set of libraries.</p><h2 class="nc kd ih bn ke nd ne nf ki ng nh ni km jp nj nk kq jt nl nm ku jx nn no ky np gi" style="text-decoration: none;" id="ContractTestingBestPractices-Terminology"><span class="handy-header aui-icon aui-icon-small aui-iconfont-link" title="Copy link"></span>Terminology</h2><ol style="text-decoration: none;"><li class="lv lw ih jg b jh la jl lb jp oe jt of jx og kb ma mb mc md gi" style="list-style-type: decimal;"><strong class="jg ii">Consumer</strong><span>&nbsp;</span>— any party that interacts with a dependent service through an API (HTTP, event-based, etc). This often drills down to be a backend interacting with another backend API, but it doesn’t have to be. A browser frontend is also a valid party that depends on a backend API and is considered a consumer.</li><li class="lv lw ih jg b jh mf jl mg jp mh jt mi jx mj kb ma mb mc md gi" style="list-style-type: decimal;"><strong class="jg ii">Provider</strong><span>&nbsp;</span>— any party that provides a service for interacting with to its dependents.</li><li class="lv lw ih jg b jh mf jl mg jp mh jt mi jx mj kb ma mb mc md gi" style="list-style-type: decimal;"><strong class="jg ii">Contracts</strong><span>&nbsp;</span>— just like law enforceable agreements, these contracts represent a set of interactions with expected request and response structures. Through-out this document we will use Pacts and Contracts interchangeably to refer to the contract.</li><li class="lv lw ih jg b jh mf jl mg jp mh jt mi jx mj kb ma mb mc md gi" style="list-style-type: decimal;"><strong class="jg ii">Broker</strong><span>&nbsp;</span>— the contracts need a place to be stored. It can be any generic assets server, but its better if they are versioned, so version control is a choice.&nbsp;</li></ol><p class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi"><strong class="jg ii">The consumer</strong><span>&nbsp;</span>part is defining the API contract by setting expectations of the provider request and response structure. These sets of interactions make the contract between a consumer and its provider.</p><p class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi"><strong class="jg ii">The contract</strong><span>&nbsp;</span>is then published to a pact broker which is a central place to inspect and manage the contracts.</p><p class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi">The<span>&nbsp;</span><strong class="jg ii">pact broker</strong><span>&nbsp;</span>holds the contracts and provides added value such as displaying whether contracts have been verified, what interactions exist between services, and other features.</p><p class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi"><strong class="jg ii">The provider</strong><span>&nbsp;</span>is providing the API, and in its turn, pulls contracts from the broker to run its test against, and verify whether its own test suite is breaking or not, which it then reports back to the broker.</p><h2 class="anchor anchorWithStickyNavbar_mojV" style="text-decoration: none;" id="ContractTestingBestPractices-WhatisPactgoodfor?​"><span class="handy-header aui-icon aui-icon-small aui-iconfont-link" title="Copy link"></span>What is Pact good for?<a class="external-link" href="https://docs.pact.io/getting_started/what_is_pact_good_for#what-is-pact-good-for" title="Direct link to heading" rel="nofollow">​</a></h2><p>Pact is most valuable for designing and testing integrations where:</p><ul style="text-decoration: none;"><li>You<span>&nbsp;</span>(or your team/organisation/partner organisation)<span>&nbsp;</span>control the development of both the consumer and the provider.</li><li>The consumer and provider are both under active development.</li><li>The provider team can easily control the data returned in the provider's responses.</li><li>There is a small enough number of consumers for a given provider that the provider team can manage an individual relationship with each consumer team.</li></ul><p>The primary advantages are:</p><ul style="text-decoration: none;"><li>You can continuously evolve your codebases knowing that Pact will guarantee contracts are met.</li><li>You can find out<span>&nbsp;</span><em>before</em><span>&nbsp;</span>you deploy whether or not your applications will work together - there is no need to wait for slow e2e tests.</li></ul><h2 class="anchor anchorWithStickyNavbar_mojV" style="text-decoration: none;" id="ContractTestingBestPractices-Whatisitnotgoodfor?​"><span class="handy-header aui-icon aui-icon-small aui-iconfont-link" title="Copy link"></span>What is it not good for?<a class="external-link" title="Direct link to heading" href="https://docs.pact.io/getting_started/what_is_pact_good_for#what-is-it-not-good-for" rel="nofollow">​</a></h2><ul style="text-decoration: none;"><li>Testing APIs where the team maintaining the other side of the integration will not also be using Pact</li><li>Testing APIs where the consumers cannot be individually identified<span>&nbsp;</span>(eg. public APIs).</li><li>Situations where you cannot load data into the provider without using the API that you're actually testing<span>&nbsp;</span>(eg. public APIs).</li><li>Situations where you cannot control the data being used to generate the provider's responses.</li><li>Testing providers where the consumer and provider teams do not have good communication channels.</li><li>Performance and load testing.</li><li>Functional testing<span>&nbsp;</span>of the provider - that is what the provider's own tests should do. Pact is about checking the contents and format of requests and responses.</li><li>Testing "pass through" APIs, where the provider merely passes on the request contents to a downstream service without validating them.<span>&nbsp;</span></li></ul><h3 id="ContractTestingBestPractices-WriteConsumerContracttestsforallAPIinteractions"><span class="handy-header aui-icon aui-icon-small aui-iconfont-link" title="Copy link"></span><span>Write Consumer Contract tests for all API interactions</span></h3><p><span><span><span><span style="color: rgb(41,41,41);"><span>With</span>&nbsp;the Service Oriented Architecture (i.e: microservices) within HMCTs, there is a high level of importance of testing these API interactions with other service teams/ common components in order to add a layer of confidence as different teams deploy new versions and risk breaking an API contract with some of the other teams they integrate with.</span></span></span></span></p><h3 id="ContractTestingBestPractices-Followthenamingstandardsforparticipants"><span class="handy-header aui-icon aui-icon-small aui-iconfont-link" title="Copy link"></span><span><span><span><span style="color: rgb(41,41,41);">Follow the naming standards for participants</span></span></span></span></h3><p><span><span><span><span><span style="color: rgb(41,41,41);"><span>These</span>&nbsp;can be found here:</span></span></span></span></span></p><p><span><span><span><span style="color: rgb(41,41,41);"><span style="color: rgb(23,43,77);text-decoration: none;"><a href="https://tools.hmcts.net/confluence/pages/viewpage.action?pageId=1056801038&amp;__ncforminfo=Bk6yuEH6-lXLNPj60tDEuWu800KaywUmRCoPQB6WrLt3lYe693JubaaRv_mEWtjqGiL0m2pzHUGS1chiC64eG--O9y-Kotry#Pactguidelines-Pacticipants" rel="nofollow">https://tools.hmcts.net/confluence/pages/viewpage.action?pageId=1056801038#Pactguidelines-Pacticipants</a></span></span></span></span></span></p><h3 id="ContractTestingBestPractices-Avoidrandomdatainexpectations"><span class="handy-header aui-icon aui-icon-small aui-iconfont-link" title="Copy link"></span>Avoid random data in expectations</h3><p>This is a general rule about writing tests so that your tests are consistent and reproducible. When working with pact, it is even more important to avoid random data when writing consumer tests because the pact broker calculates a hash of the contract, and when that hash is the same, meaning the contract didn’t change even if you re-published it, then no further provider verification results are required. However, if the hash is different, then contract changed and so it will be considered as a new contract that needs to be verified by the provider. If you add random data you forgo of this optimization that the pact broker is doing for you.</p><h3 id="ContractTestingBestPractices-MatchTypesorRegexesinsteadofhard-codedstaticdata"><span class="handy-header aui-icon aui-icon-small aui-iconfont-link" title="Copy link"></span>Match Types or Regexes instead of hard-coded static data</h3><p>&nbsp;You may write your consumer contract tests in a way that expects a hard-coded static property, like say an<span>&nbsp;</span><em class="me">id</em><span>&nbsp;</span>property with value of<span>&nbsp;</span><strong class="jg ii"><em class="me">1</em></strong>, or a<span>&nbsp;</span><em class="me">name</em><span>&nbsp;</span>property with value of<span>&nbsp;</span><strong class="jg ii"><em class="me">John</em></strong>. This tightly couples the consumer test with the provider test as these exact matches would be enforced when the contract is being replayed using the pact runner. Instead, prefer to specify the expected type, or an expected pattern using regular expressions which enables more freedom in data and states management on the provider contract testing side. This&nbsp;</p><h3 id="ContractTestingBestPractices-OneContracttestperConsumer-Providerinteraction"><span class="handy-header aui-icon aui-icon-small aui-iconfont-link" title="Copy link"></span>One Contract test per Consumer-Provider interaction</h3><p>Follow the rule of one test file per consumer-provider interaction. If you split your consumer testing across multiple files for one consumer-provider contract then you incur added complexity such as: a test runner that parallelizes test execution like Ava.js or Jest will have conflicting instances of the mock service running on the same port for the provider mock; finalizing the pact contract happens once all interactions finished, how will that be ensured when they execute asynchronously and in parallel?<br>The Pact framework was originally also designed to run tests in a serial manner. It’s not impossible of course, but will require a more elaborate setup for parallel tests.</p><h3 class="c11" style="text-decoration: none;text-align: left;" id="ContractTestingBestPractices-PublishtheConsumerContracttothePactBroker"><span class="handy-header aui-icon aui-icon-small aui-iconfont-link" title="Copy link"></span><span class="c2 c17" style="color: rgb(0,0,0);text-decoration: none;">Publish the Consumer Contract to the PactBroker</span></h3><p class="c9" style="text-align: left;"><span>&nbsp;The artifacts that tie the Consumer and Provider Tests together are the pact, and the verification results. The&nbsp;</span><span class="c13" style="color: rgb(17,85,204);text-decoration: underline;"><a style="text-decoration: inherit;" href="https://www.google.com/url?q=https://github.com/pact-foundation/pact_broker&amp;sa=D&amp;source=editors&amp;ust=1660832912754057&amp;usg=AOvVaw0pHx8pnr4MlQqU7YWF8p2-" class="external-link" rel="nofollow">Pact Broker</a></span><span>&nbsp;is a service that allows your projects to exchange pacts and verification results in an automated way. While you can use Pact without a Pact Broker, using one allows you to get the most out Pact. The Pact Broker is designed to operate within our test frameworks and CI system, and as such, has integration points in each of the Pact implementations to publish and retrieve contracts and results. &nbsp;<br><br>Please see link below for our central HMCTS PactBroker:<br><a href="https://pact-broker.platform.hmcts.net/" class="external-link" rel="nofollow">https://pact-broker.platform.hmcts.net</a>&nbsp;(requires F5 VPN)<br></span></p><p class="c9" style="text-align: left;"><span><span class="c2 c5"><span style="color: rgb(0,0,0);">Configure your consumer build to publish its pact to the broker using the Jenkins hooks.&nbsp;<span>For</span>&nbsp;example in the build.gradle add something like the following:</span></span></span></p><p><code class="java plain" style="text-align: left;">=== build.gradle ===</code></p><pre data-bidi-marker="true"><span style="color: rgb(152,118,170);">project</span>.ext <span>{<br></span><span>    </span>pacticipant = <span style="color: rgb(106,135,89);">'fr_paymentService'<br></span><span style="color: rgb(106,135,89);">    </span>pacticipantVersion = getCheckedOutGitCommitHash()<br><span>}<br></span></pre><pre data-bidi-marker="true">task runAndPublishConsumerPactTests(type: Test) {<br>testClassesDirs = sourceSets.contract.output.classesDirs<br>classpath = sourceSets.contract.runtimeClasspath<br><br>}<br><br>runAndPublishConsumerPactTests.finalizedBy pactPublish<br><br>pact {<br> broker {<br> pactBrokerUrl = System.getenv("PACT_BROKER_FULL_URL") ?: 'http://localhost:80'<br> }<br> publish {<br> pactDirectory = 'pacts'<br> tags = [System.getenv("PACT_BRANCH_NAME") ?: 'Dev']<br>version = project.pacticipantVersion<br>}<br>}</pre><p><span><code class="java plain" style="text-align: left;">======</code><br></span></p><p><span>e.g → <a href="https://github.com/hmcts/finrem-payment-service/blob/4609130cfc3a7c452eb896fac65f309647c2051b/build.gradle#L337" class="external-link" rel="nofollow">https://github.com/hmcts/finrem-payment-service/blob/4609130cfc3a7c452eb896fac65f309647c2051b/build.gradle#L337</a></span></p><p><span><br>And in jenkins add the following which enables the jenkins hooks to gradle(java)/ package.json (node):&nbsp;<br></span><code class="java plain" style="text-align: left;">=== Jenkinsfile_CNP ===</code><br><code class="java spaces" style="text-align: left;">&nbsp;</code><code class="java plain" style="text-align: left;">enablePactAs([</code><br><code class="java spaces" style="text-align: left;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="java plain" style="text-align: left;">AppPipelineDsl.PactRoles.CONSUMER</code><br><code class="java spaces" style="text-align: left;">&nbsp;</code><code class="java plain" style="text-align: left;">])</code></p><p><span><code class="java plain" style="text-align: left;">======</code></span></p><p><span>e.g -&gt; <a href="https://github.com/hmcts/finrem-payment-service/blob/4609130cfc3a7c452eb896fac65f309647c2051b/Jenkinsfile_CNP#L75" class="external-link" rel="nofollow">https://github.com/hmcts/finrem-payment-service/blob/4609130cfc3a7c452eb896fac65f309647c2051b/Jenkinsfile_CNP#L75</a></span></p><p><br></p><p>Now every time the job is run, the contract will be published to the Pact Broker with the git commit hash as application version&nbsp;and it will be tagged with the current branch name. The tag will help the provider in knowing which version to verify. If you open the broker now you will see this entry in the matrix view of the contract:</p><p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" draggable="false" width="1112" src="/confluence/download/attachments/1604504936/Screenshot%202022-08-19%20at%2012.10.50.png?version=1&amp;modificationDate=1660907468424&amp;api=v2&amp;__ncforminfo=Bk6yuEH6-lXLNPj60tDEuWu800KaywUmff9qUzS_kmsy8hZ6mSmk19cPvbblfhLuYhf5T_pWbXQUToR-AtoqEjnX5RfhC8Olj31lhNEHWvuCezmvZQkA5g==" data-image-src="/confluence/download/attachments/1604504936/Screenshot%202022-08-19%20at%2012.10.50.png?version=1&amp;modificationDate=1660907468424&amp;api=v2" data-unresolved-comment-count="0" data-linked-resource-id="1604506023" data-linked-resource-version="1" data-linked-resource-type="attachment" data-linked-resource-default-alias="Screenshot 2022-08-19 at 12.10.50.png" data-base-url="https://tools.hmcts.net/confluence" data-linked-resource-content-type="image/png" data-linked-resource-container-id="1604504936" data-linked-resource-container-version="24" alt=""></span></p><h3 id="ContractTestingBestPractices-Configureyourproviderbuildtofetchthepactfromthebroker"><span class="handy-header aui-icon aui-icon-small aui-iconfont-link" title="Copy link"></span><span class="c2 c5" style="color: rgb(0,0,0);text-decoration: none;">Configure your provider build to fetch the pact from the broker </span></h3><p class="c9" style="text-align: left;"><span class="c2 c1" style="color: rgb(0,0,0);text-decoration: none;">“Tagging” application versions in the broker allows you to introduce new expectations to a pact without breaking your provider builds. It’s an approach similar to git feature branches, where you can keep an unbreaking main line of development, while adding new, breaking interactions on the side.</span></p><p class="c9" style="text-align: left;"><span class="c2 c1" style="color: rgb(0,0,0);text-decoration: none;">To achieve this, when a pact is published, its associated pacticipant version is tagged with an identifier that will be used by the provider to differentiate between the “main line” safe pacts (eg. tagged “master”) and the potentially breaking pacts (eg. tagged “feat-new-foobar”)</span></p><p class="c9" style="text-align: left;"><span class="c1">To keep a green build in your provider’s CI, rather than verifying the latest<span>&nbsp;</span></span><span class="c1 c0">overall</span><span class="c2 c1" style="color: rgb(0,0,0);text-decoration: none;">&nbsp;pact, it should verify the pact for the latest version tagged with “master” in the CI <span class="c2 c5" style="color: rgb(0,0,0);text-decoration: none;">and publish the verification results as long as the following Environment Variable is set to "true" :</span></span></p><pre class="c9" data-bidi-marker="true">pact.verifier.publishResult</pre><p class="c9" style="text-align: left;"><span class="c2 c1" style="color: rgb(0,0,0);text-decoration: none;"><span class="c2 c5" style="color: rgb(0,0,0);text-decoration: none;">This environment variable is set automatically via the Jenkins pipeline for "master" branches for projects with the following configuration enabled in Jenkinsfile_CNP:</span></span></p><p><code class="java plain" style="text-align: left;">=== Jenkinsfile_CNP ===</code><br><code class="java spaces" style="text-align: left;">&nbsp;</code><code class="java plain" style="text-align: left;">enablePactAs([</code><br><code class="java spaces" style="text-align: left;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="java plain" style="text-align: left;">AppPipelineDsl.PactRoles.PROVIDER</code><br><code class="java spaces" style="text-align: left;">&nbsp;</code><code class="java plain" style="text-align: left;">])</code></p><p><span><code class="java plain" style="text-align: left;">======</code></span></p><p><span>e.g → <a href="https://github.com/hmcts/aac-manage-case-assignment/blob/7458dc46ede8aa6a0c44aad045c5938c8e989111/Jenkinsfile_CNP#L111" class="external-link" rel="nofollow">https://github.com/hmcts/aac-manage-case-assignment/blob/7458dc46ede8aa6a0c44aad045c5938c8e989111/Jenkinsfile_CNP#L111</a></span></p><p><span><span><span style="color: rgb(0,0,0);">When you use a feature branch for the Consumer and that contract has not been changed the PactBroker will automatically figure out that nothing has changed and will verify the feature branch version of the pact from the last "master' verification. If you have a made changes to the to the Consumer Pact then this needs to verified by liaising with&nbsp;<span>the</span>&nbsp;Provider team to provide the&nbsp;verification manually. This can be done by&nbsp;amending the Tag in the Provider Test to match the feature-branch name.</span></span></span></p><p><span><span><span style="color: rgb(0,0,0);">e.g → <a href="https://github.com/hmcts/aac-manage-case-assignment/blob/7458dc46ede8aa6a0c44aad045c5938c8e989111/src/contractTest/java/uk/gov/hmcts/reform/managecase/api/controller/provider/CasesAssignmentControllerProviderTest.java#L46" class="external-link" rel="nofollow">https://github.com/hmcts/aac-manage-case-assignment/blob/7458dc46ede8aa6a0c44aad045c5938c8e989111/src/contractTest/java/uk/gov/hmcts/reform/managecase/api/controller/provider/CasesAssignmentControllerProviderTest.java#L46</a></span></span></span></p><h3 id="ContractTestingBestPractices-Usethecan-i-deploytoolinyourpipelinetocheckwhetheritssafetodeploy"><span class="handy-header aui-icon aui-icon-small aui-iconfont-link" title="Copy link"></span><span><span><span style="color: rgb(0,0,0);">Use the can-i-deploy tool in your pipeline to check whether its safe to deploy</span></span></span></h3><p class="c9" style="text-align: left;"><span class="c1">One very important thing to note is that a verification is associated with<span>&nbsp;</span></span><span class="c1">the pact<span>&nbsp;</span></span><span class="c1 c0">content</span><span class="c1">&nbsp;itself</span><span class="c2 c1" style="color: rgb(0,0,0);text-decoration: none;">, not to a specific consumer version. This means that if a pact does not change between publications, any previous verifications can automatically be applied to the new pact publication, effectively “pre-verifying” it. (For this reason, it is best not to use any random data in a pact, as this will cause the broker to consider it a new revision of the pact.) </span></p><p class="c9" style="text-align: left;"><span class="c1">The way you check if you are safe to deploy is to determine if there is a row in the matrix that contains the version of the application you’re about to deploy<span>&nbsp;</span></span><span class="c1 c0">and</span><span class="c1">&nbsp;the version of the other application that already exists in that environment. You can do this with the can-i-deploy tool, which</span><span class="c1">&nbsp;can be enabled by enabling another Jenkins hook by adding the following role to the Jenkinsfile_CNP as follows:</span></p><p><code class="java plain" style="text-align: left;">=== Jenkinsfile_CNP ===</code><br><code class="java spaces" style="text-align: left;">&nbsp;</code><code class="java plain" style="text-align: left;">enablePactAs([</code><br><code class="java spaces" style="text-align: left;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="java plain" style="text-align: left;">AppPipelineDsl.PactRoles.CONSUMER_DEPLOY_CHECK</code></p><p><code class="java spaces" style="text-align: left;">&nbsp;</code><code class="java plain" style="text-align: left;">])</code></p><h3 style="text-decoration: none;" id="ContractTestingBestPractices-Don'tmarktestsasIgnored"><span class="handy-header aui-icon aui-icon-small aui-iconfont-link" title="Copy link"></span>Don't mark tests as Ignored</h3><p style="">When you discover that a test is flaky, you should react as soon as possible; if you allow yourself to ignore flaky tests, things can only worsen. Tests should never be ignored, if not needed remove completely</p><p><br></p><p><br></p>

                
        
    
        </div>
